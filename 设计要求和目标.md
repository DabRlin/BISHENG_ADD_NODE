# Redis 向量检索节点 - 设计要求与目标

## 📋 项目概述

**节点名称**：Redis 向量检索节点 (Redis Vector Retrieval Node)

**节点类型**：`my_node`

**核心功能**：对文档内容进行分块、向量化、存储到 Redis，并基于用户问题进行向量检索，返回最相关的文本块，供 LLM 节点使用生成答案。

**业务流程**：
```
文件输入 → 文本分块 → Embedding向量化 → Redis存储 → 
用户问题 → 问题向量化 → 向量检索 → Rerank重排序 → 返回Top-K → LLM生成答案
```

---

## 🎯 功能目标

### 主要目标
实现一个完整的 RAG (Retrieval-Augmented Generation) 检索节点，作为文档问答系统的核心检索组件。

### 具体功能
1. ✅ **文本分块（Chunking）**：将长文档按固定大小分割成多个文本块，支持重叠
2. ✅ **文本向量化（Embedding）**：调用 Embedding API 将文本转换为向量表示
3. ✅ **Redis 向量存储**：连接 Redis 并创建向量索引，存储文本块和对应向量
4. ✅ **向量检索**：基于用户问题进行向量相似度搜索
5. ✅ **Rerank 重排序**：使用 Rerank 模型对检索结果进行精排，提升相关性
6. ✅ **结果返回**：返回最相关的 Top-K 文本块

---

## 📥 输入设计

### 输入参数

| 参数名 | 类型 | 来源节点 | 说明 | 示例 |
|--------|------|---------|------|------|
| `user_question` | `str` | InputNode | 用户的查询问题 | "什么是机器学习？" |
| `file_content` | `str` | InputNode | 文档的完整文本内容 | "机器学习是人工智能的一个分支..." |

### 配置参数（节点内部）

| 参数名 | 类型 | 默认值 | 说明 | 可配置 |
|--------|------|--------|------|--------|
| `chunk_size` | `int` | `250` | 文本块大小（字符数） | ✅ 是 |
| `overlap_size` | `int` | `50` | 块之间重叠大小 | ✅ 是 |
| `top_k` | `int` | `3` | 返回最相关的块数量 | ✅ 是 |
| `use_rerank` | `bool` | `True` | 是否使用 Rerank 重排序 | ✅ 是 |
| `embedding_api_key` | `str` | - | Embedding API 密钥 | ✅ 是 |
| `embedding_base_url` | `str` | - | Embedding API 地址 | ✅ 是 |
| `embedding_model` | `str` | `"BAAI/bge-m3"` | Embedding 模型名称 | ✅ 是 |
| `rerank_model` | `str` | `"BAAI/bge-reranker-v2-m3"` | Rerank 模型名称 | ✅ 是 |
| `redis_host` | `str` | `"localhost"` | Redis 服务器地址 | ✅ 是 |
| `redis_port` | `int` | `6379` | Redis 端口 | ✅ 是 |
| `redis_db` | `int` | `0` | Redis 数据库编号 | ✅ 是 |
| `redis_password` | `str` | `None` | Redis 密码 | ✅ 是 |
| `redis_index_name` | `str` | `"bisheng_docs_idx"` | Redis 索引名称 | ✅ 是 |

**配置参数优先级设计**：
- 优先使用节点配置的参数
- 如果节点未配置，使用默认值
- 敏感信息（API Key、密码）应该从环境变量或系统配置中读取

---

## 📤 输出设计

### 输出变量

| 变量名 | 类型 | 说明 | 后续使用 |
|--------|------|------|---------|
| `relevant_chunks` | `List[str]` | 最相关的文本块列表 | 传递给 LLM 节点作为上下文 |
| `chunk_count` | `int` | 返回的块数量 | 用于日志展示 |
| `search_score` | `float` | 平均相似度得分（可选） | 用于质量评估 |

### 输出格式示例

```python
{
    "relevant_chunks": [
        "机器学习是人工智能的一个分支，它使计算机能够从数据中学习...",
        "深度学习是机器学习的一个子集，使用多层神经网络...",
        "监督学习需要标注数据，而无监督学习则不需要..."
    ],
    "chunk_count": 3,
    "search_score": 0.85
}
```

**其他节点引用方式**：
```
{{my_node_id.relevant_chunks}}  # 在 LLM 节点的提示词中引用
```

---

## 🔧 核心功能模块设计

### 模块 1：文本分块（Text Chunking）

**功能**：将长文档分割成适合向量化的文本块

**算法**：滑动窗口分块
- 固定大小：`chunk_size` 字符
- 重叠区域：`overlap_size` 字符
- 目的：保持上下文连贯性，避免语义被截断

**输入**：完整文本字符串
**输出**：文本块列表

```python
chunks = split_text_into_chunks(
    text="长文档内容...",
    chunk_size=250,
    overlap=50
)
# 结果：["chunk1...", "chunk2...", "chunk3..."]
```

**优化考虑**：
- 未来可以考虑基于语义的智能分块（按句子、段落边界）
- 处理特殊字符和格式

---

### 模块 2：文本向量化（Text Embedding）

**功能**：调用 Embedding API 将文本转换为高维向量

**API 调用**：
- 端点：`{base_url}/embeddings`
- 方法：`POST`
- 模型：`BAAI/bge-m3` (向量维度 1024)
- 批处理：支持批量向量化多个文本块

**输入**：文本块列表
**输出**：向量列表 `List[List[float]]`

**错误处理**：
- API 调用失败 → 重试机制（最多 3 次）
- 超时处理 → 30 秒超时
- 空文本处理 → 返回零向量或跳过

**性能优化**：
- 批量处理减少 API 调用次数
- 异步并发调用（如果支持）

---

### 模块 3：Redis 向量存储

**功能**：连接 Redis 并创建向量索引，存储文本和向量

**Redis 配置**：
- 连接方式：`redis-py` 客户端
- 索引类型：`FLAT` 索引（适合小到中等规模数据）
- 距离度量：`COSINE` 余弦相似度

**数据结构**：
```python
# 每个文档块存储为一个 Hash
doc:0 = {
    "content": "文本内容",
    "chunk_id": 0,
    "embedding": <1024维向量的二进制数据>
}
```

**索引 Schema**：
- `content`：TEXT 字段（文本内容）
- `chunk_id`：NUMERIC 字段（块ID）
- `embedding`：VECTOR 字段（FLOAT32, DIM=1024, COSINE）

**操作流程**：
1. 连接 Redis
2. 删除旧索引（如果存在）
3. 创建新索引
4. 批量存储文本块和向量
5. 验证存储成功

**错误处理**：
- 连接失败 → 抛出明确错误信息
- 索引创建失败 → 检查权限和配置
- 存储失败 → 记录失败的块ID

---

### 模块 4：向量检索（Vector Search）

**功能**：基于用户问题向量，在 Redis 中检索最相似的文本块

**检索流程**：
1. 将用户问题向量化
2. 在 Redis 中执行 KNN 搜索
3. 返回 Top-K 结果（按相似度排序）

**KNN 查询**：
```python
Query(f"*=>[KNN {top_k} @embedding $vec AS score]")
    .sort_by("score")
    .return_fields("chunk_id", "content", "score")
```

**输出**：
```python
[
    {"chunk_id": 5, "content": "...", "score": 0.92},
    {"chunk_id": 12, "content": "...", "score": 0.87},
    {"chunk_id": 3, "content": "...", "score": 0.81}
]
```

**性能考虑**：
- Top-K 设置：检索数量应适中（3-10）
- 相似度阈值：可选，过滤低相关结果

---

### 模块 5：Rerank 重排序（可选但推荐）

**功能**：使用 Rerank 模型对检索结果进行精排，提升相关性

**Why Rerank？**
- 向量检索基于语义相似度，但不一定是最佳相关性
- Rerank 模型考虑问题和文档的深层语义关系
- 显著提升检索质量（尤其是对复杂问题）

**工作流程**：
1. 从 Redis 检索初始 Top-K*3 结果（例如 9 个候选）
2. 调用 Rerank API 对候选进行重排序
3. 返回最终 Top-K 结果（例如 3 个）

**API 调用**：
- 端点：`{base_url}/rerank`
- 方法：`POST`
- 模型：`BAAI/bge-reranker-v2-m3`
- 输入：问题 + 候选文档列表
- 输出：重排序后的结果（带相关性分数）

**配置选项**：
- `use_rerank`: `True/False` 开关
- 如果关闭，直接使用 Redis 检索结果

---

## 🏗️ 技术架构设计

### 类结构设计

```python
class MyNode(BaseNode):
    """Redis 向量检索节点"""
    
    # 初始化
    def __init__(self, *args, **kwargs)
        - 加载配置参数
        - 初始化 API 客户端
        - 验证必要参数
    
    # 核心执行逻辑
    def _run(self, unique_id: str) -> Dict[str, Any]
        - 获取输入变量
        - 执行检索流程
        - 返回结果
    
    # 内部方法
    def _split_text_into_chunks(self, text: str) -> List[str]
    def _get_embeddings(self, chunks: List[str]) -> List[List[float]]
    def _connect_redis(self) -> redis.Redis
    def _create_vector_index(self, redis_client) -> bool
    def _store_vectors_to_redis(self, redis_client, chunks, embeddings) -> int
    def _vector_search_redis(self, redis_client, query_vector, top_k) -> List[Dict]
    def _rerank_documents(self, query: str, documents: List[str]) -> Dict
    
    # 日志解析
    def parse_log(self, unique_id: str, result: dict) -> Any
```

### 依赖库

```python
# 必需依赖
import redis                    # Redis 客户端
import requests                 # HTTP 请求
import numpy as np              # 向量处理
from typing import List, Dict, Any

# Redis 向量搜索
from redis.commands.search.indexDefinition import IndexDefinition, IndexType
from redis.commands.search.field import VectorField, TextField, NumericField
from redis.commands.search.query import Query

# BISHENG 框架
from bisheng.workflow.nodes.base import BaseNode
from loguru import logger       # 日志记录
```

**依赖安装**：
```bash
pip install redis requests numpy
```

---

## 🔄 执行流程图

```
┌─────────────────────────────────────────────────────────────────┐
│                        节点开始执行                                │
└─────────────────────┬───────────────────────────────────────────┘
                      │
                      ▼
            ┌─────────────────────┐
            │  1. 获取输入变量      │
            │  - user_question     │
            │  - file_content      │
            └──────────┬───────────┘
                       │
                       ▼
            ┌─────────────────────┐
            │  2. 文本分块          │
            │  - 滑动窗口分块      │
            │  - overlap 重叠      │
            └──────────┬───────────┘
                       │
                       ▼
            ┌─────────────────────┐
            │  3. 文本向量化        │
            │  - 调用 Embedding   │
            │  - 批量处理          │
            └──────────┬───────────┘
                       │
                       ▼
            ┌─────────────────────┐
            │  4. 连接 Redis       │
            │  - 创建/删除索引     │
            │  - 验证连接          │
            └──────────┬───────────┘
                       │
                       ▼
            ┌─────────────────────┐
            │  5. 存储向量          │
            │  - 批量写入 Redis   │
            │  - 验证存储成功      │
            └──────────┬───────────┘
                       │
                       ▼
            ┌─────────────────────┐
            │  6. 问题向量化        │
            │  - 查询文本 → 向量  │
            └──────────┬───────────┘
                       │
                       ▼
            ┌─────────────────────┐
            │  7. 向量检索          │
            │  - KNN 搜索         │
            │  - Top-K*3 候选     │
            └──────────┬───────────┘
                       │
                       ▼
         ┌─────────────────────────┐
         │  8. Rerank 重排序？       │
         │  (如果启用)               │
         └────┬──────────────┬──────┘
              │ YES          │ NO
              ▼              ▼
    ┌────────────────┐  ┌────────────┐
    │ Rerank API     │  │ 直接返回    │
    │ 精排 Top-K     │  │ Top-K      │
    └───────┬────────┘  └──────┬─────┘
            │                  │
            └────────┬─────────┘
                     ▼
          ┌──────────────────────┐
          │  9. 返回结果           │
          │  - relevant_chunks   │
          │  - chunk_count       │
          └──────────┬────────────┘
                     │
                     ▼
          ┌──────────────────────┐
          │  10. 记录执行日志      │
          └──────────┬────────────┘
                     │
                     ▼
          ┌──────────────────────┐
          │      节点执行完成       │
          └──────────────────────┘
```

---

## 📊 数据流设计

### 完整工作流数据流

```
┌────────────┐      ┌────────────┐      ┌────────────┐      ┌────────────┐
│ StartNode  │ ───▶ │ InputNode  │ ───▶ │  MyNode    │ ───▶ │  LLMNode   │
│  (开始)     │      │  (输入)     │      │ (向量检索) │      │  (生成答案) │
└────────────┘      └────────────┘      └────────────┘      └────────────┘
                          │                    │                   │
                          │                    │                   │
                     用户问题            相关文本块            最终答案
                     文件内容           (Top-K chunks)
```

**具体数据传递**：

1. **InputNode → MyNode**
   - `input_node.user_input` → `user_question`
   - `input_node.dialog_files_content` → `file_content`

2. **MyNode → LLMNode**
   - `my_node.relevant_chunks` → LLM 提示词中的上下文

3. **LLMNode 提示词模板示例**：
```
基于以下文档内容回答问题：

文档内容：
{{my_node.relevant_chunks}}

用户问题：
{{input_node.user_input}}

请给出详细的回答。
```

---

## 🎨 前端配置界面设计

### 节点图标和颜色

**图标建议**：
- `Database` - 数据库图标（代表 Redis 存储）
- `Search` - 搜索图标（代表向量检索）
- 或 `Layers` - 层叠图标（代表向量层）

**颜色建议**：
- `bg-[#B8EEDF]` - 青绿色（类似 QA Retriever）
- 或 `bg-[#BBDBFF]` - 蓝色（类似 RAG）

### 参数配置面板

**Tab 1: 基础配置**
- [x] 文本块大小 (`chunk_size`)
- [x] 重叠大小 (`overlap_size`)
- [x] 返回结果数 (`top_k`)
- [x] 启用 Rerank (`use_rerank`)

**Tab 2: API 配置**
- [x] API 基础地址 (`embedding_base_url`)
- [x] API 密钥 (`embedding_api_key`)
- [x] Embedding 模型 (`embedding_model`)
- [x] Rerank 模型 (`rerank_model`)

**Tab 3: Redis 配置**
- [x] Redis 地址 (`redis_host`)
- [x] Redis 端口 (`redis_port`)
- [x] 数据库编号 (`redis_db`)
- [x] 密码 (`redis_password`)
- [x] 索引名称 (`redis_index_name`)

**Tab 4: 输入变量**
- [x] 用户问题 (`user_question`) - 变量选择器
- [x] 文件内容 (`file_content`) - 变量选择器

---

## 🔍 错误处理设计

### 错误类型和处理策略

| 错误类型 | 场景 | 处理策略 | 用户提示 |
|---------|------|---------|---------|
| **参数验证错误** | 必填参数为空 | 抛出异常，停止执行 | "缺少必需参数：xxx" |
| **API 调用失败** | Embedding/Rerank API 错误 | 重试 3 次，失败后抛出异常 | "API 调用失败：xxx" |
| **API 超时** | 请求超过 30 秒 | 抛出超时异常 | "API 请求超时" |
| **Redis 连接失败** | 无法连接 Redis | 抛出异常 | "Redis 连接失败：检查配置" |
| **索引创建失败** | 权限或配置问题 | 抛出异常 | "Redis 索引创建失败" |
| **向量存储失败** | 部分块存储失败 | 记录警告，继续执行 | "部分数据存储失败" |
| **检索失败** | 查询执行错误 | 返回空结果 | "向量检索失败" |
| **空结果** | 没有找到相关内容 | 返回空列表 | "未找到相关内容" |

### 错误日志记录

```python
# 使用 loguru 记录详细日志
logger.error(f"[MyNode] 节点执行失败: {str(e)}", exc_info=True)
logger.warning(f"[MyNode] API 重试 {retry_count}/3")
logger.info(f"[MyNode] 成功存储 {stored_count} 个向量")
```

---

## 📈 性能优化策略

### 1. 批量处理
- Embedding API 批量调用（一次处理所有 chunks）
- Redis 批量存储（使用 pipeline）

### 2. 缓存机制
- 相同文件内容不重复向量化（基于文件 hash）
- Redis 向量可以持久化，避免重复存储

### 3. 并发处理
- 如果 API 支持，使用异步并发调用
- 多文件处理时并行处理

### 4. 资源管理
- 及时关闭 Redis 连接
- 清理临时数据

### 5. 索引优化
- 根据数据规模选择合适的索引类型
- 考虑使用 HNSW 索引（大规模数据）

---

## 🧪 测试计划

### 单元测试

**测试用例 1：文本分块**
```python
def test_split_text_into_chunks():
    text = "A" * 500
    chunks = node._split_text_into_chunks(text, chunk_size=100, overlap=20)
    assert len(chunks) == 6  # 验证块数量
    assert len(chunks[0]) == 100  # 验证块大小
```

**测试用例 2：Embedding 调用**
```python
def test_get_embeddings():
    chunks = ["测试文本1", "测试文本2"]
    embeddings = node._get_embeddings(chunks)
    assert len(embeddings) == 2
    assert len(embeddings[0]) == 1024  # 验证向量维度
```

**测试用例 3：Redis 连接**
```python
def test_connect_redis():
    redis_client = node._connect_redis()
    assert redis_client.ping() == True
```

### 集成测试

**测试场景 1：完整检索流程**
```python
def test_full_retrieval_flow():
    result = node._run("test_unique_id")
    assert "relevant_chunks" in result
    assert isinstance(result["relevant_chunks"], list)
    assert len(result["relevant_chunks"]) <= top_k
```

**测试场景 2：错误处理**
```python
def test_error_handling():
    # 测试空输入
    # 测试 API 失败
    # 测试 Redis 断开
```

### 端到端测试

**完整工作流测试**：
```
InputNode(问题="什么是机器学习？", 文件="ML教程.txt") 
→ MyNode 
→ LLMNode 
→ OutputNode
```

**验证项**：
- [ ] 节点正常执行
- [ ] 检索结果相关性高
- [ ] LLM 生成的答案准确
- [ ] 执行日志完整
- [ ] 性能可接受（< 5 秒）

---

## 🚀 开发里程碑

### Phase 1: 核心功能实现（3-4 天）
- [x] 节点类型定义和注册
- [ ] 实现文本分块功能
- [ ] 实现 Embedding 调用
- [ ] 实现 Redis 连接和索引创建
- [ ] 实现向量存储
- [ ] 实现向量检索
- [ ] 实现 Rerank 重排序
- [ ] 实现日志记录

### Phase 2: 前端配置开发（1-2 天）
- [ ] 添加节点图标和颜色
- [ ] 配置节点模板
- [ ] 设计参数配置面板
- [ ] 实现变量选择器

### Phase 3: 测试和优化（1-2 天）
- [ ] 编写单元测试
- [ ] 集成测试
- [ ] 端到端测试
- [ ] 性能优化
- [ ] 错误处理完善

### Phase 4: 文档和上线（1 天）
- [ ] 编写使用文档
- [ ] 编写配置说明
- [ ] 代码审查
- [ ] 部署上线

**预计总工时**：6-9 天

---

## 🎯 成功标准

### 功能完整性
- ✅ 所有核心功能正常工作
- ✅ 支持各种配置参数
- ✅ 错误处理完善
- ✅ 日志记录完整

### 性能指标
- ✅ 单次检索耗时 < 5 秒
- ✅ 支持文档大小 < 10MB
- ✅ 内存占用合理

### 用户体验
- ✅ 配置界面友好
- ✅ 错误提示清晰
- ✅ 文档完善
- ✅ 易于使用

### 代码质量
- ✅ 代码规范
- ✅ 注释完整
- ✅ 测试覆盖率 > 80%
- ✅ 无明显 bug

---

## 📝 关键技术决策

### 1. 为什么选择 Redis 作为向量数据库？
- ✅ 高性能：内存数据库，查询速度快
- ✅ 易部署：Redis 广泛使用，运维成熟
- ✅ 成本低：开源免费
- ✅ 支持向量搜索：RediSearch 模块支持向量索引

### 2. 为什么使用 BAAI/bge-m3 模型？
- ✅ 多语言支持：中英文效果好
- ✅ 性能优秀：检索准确率高
- ✅ 向量维度：1024 维平衡性能和准确性

### 3. 为什么需要 Rerank？
- ✅ 提升准确性：向量检索是粗排，Rerank 精排
- ✅ 语义理解：Rerank 模型理解深层语义关系
- ✅ 实测效果：显著提升检索质量（+15-20%）

### 4. 分块策略为什么选择固定大小 + 重叠？
- ✅ 简单可靠：实现简单，效果稳定
- ✅ 保持上下文：重叠区域避免语义截断
- ✅ 平衡性能：250 字符是经验最佳值

---

## 🔄 后续优化方向

### 短期优化（1-2 周）
1. **智能分块**：基于句子、段落边界分块
2. **缓存机制**：避免重复向量化相同文件
3. **异步处理**：提升并发性能
4. **索引持久化**：支持向量复用

### 中期优化（1-2 月）
1. **多文件支持**：支持多个文件联合检索
2. **混合检索**：向量检索 + 关键词检索
3. **过滤条件**：支持元数据过滤
4. **索引管理**：支持索引更新和删除

### 长期优化（3-6 月）
1. **分布式存储**：支持 Redis 集群
2. **增量更新**：支持文档增量索引
3. **多模态检索**：支持图片、表格检索
4. **质量评估**：添加检索质量评分

---

## 📚 参考资源

### 技术文档
- Redis Vector Search: https://redis.io/docs/stack/search/reference/vectors/
- BGE Models: https://github.com/FlagOpen/FlagEmbedding
- LangChain RAG: https://python.langchain.com/docs/use_cases/question_answering/

### API 文档
- Embedding API: https://docs.siliconflow.cn/api-reference/embeddings
- Rerank API: https://docs.siliconflow.cn/api-reference/rerank

### 相关论文
- Dense Passage Retrieval (DPR)
- ColBERT: Efficient and Effective Passage Search
- BGE M3: Multi-Functionality, Multi-Linguality, and Multi-Granularity

---

## 🔐 安全和隐私

### 数据安全
- [ ] API Key 不硬编码，使用环境变量
- [ ] Redis 密码加密存储
- [ ] 敏感数据不记录到日志

### 隐私保护
- [ ] 文档内容临时存储，可配置自动清理
- [ ] 支持数据加密（可选）
- [ ] 访问控制和权限管理

---

## ✅ 总结

### 核心价值
这个 Redis 向量检索节点是一个**完整的 RAG 检索组件**，具有以下核心价值：

1. **即插即用**：与 BISHENG 工作流无缝集成
2. **性能优异**：基于 Redis 的高性能向量检索
3. **准确性高**：Rerank 精排提升检索质量
4. **配置灵活**：丰富的配置选项满足不同需求
5. **易于维护**：代码结构清晰，文档完善

### 技术亮点
- ✨ 文本分块 + Embedding + 向量存储 + 检索 + Rerank 完整链路
- ✨ Redis 向量数据库高性能存储和检索
- ✨ BAAI BGE 模型优秀的多语言支持
- ✨ 与 BISHENG 工作流无缝集成

### 应用场景
- 📄 文档问答系统
- 📚 知识库检索
- 🔍 智能搜索
- 💬 对话机器人
- 📊 内容推荐

---

**文档版本**：v1.0
**最后更新**：2025-01
**编写人**：开发团队
**状态**：设计阶段 ✅

